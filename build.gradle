import org.ifcx.parsing.CharniakParser
import org.ifcx.parsing.ConvertManyPTB
import org.ifcx.parsing.DefaultTaskWithEvaluate
import org.ifcx.parsing.EnsembleParser
import org.ifcx.parsing.SetUpParser

evaluationDependsOn(':corpora')
evaluationDependsOn(':corpora:anydomain')
evaluationDependsOn(':corpora:anydomain:WSJ')

//println project
//println project(':corpora:anydomain:WSJ')
//println project(':corpora:anydomain:WSJ').tasks

apply plugin: 'base'

//apply from: 'converters.gradle'

project('wsj_only') {
    new CharniakParser(it).with {
        corpus_name = ':corpora:anydomain:WSJ'
        base_parser_dir = project.rootProject.file('bllip-parser')
        createTasks()
        createTasksForCorpus('wsj_test', project(':corpora:anydomain:WSJ').tasks.test_MRG)
        createTasksForCorpus('wsj_tune', project(':corpora:anydomain:WSJ').tasks.tune_MRG)
        createTasksForCorpus('brown_test', project(':corpora:anydomain:Brown').tasks.test_MRG)
        createTasksForCorpus('brown_tune', project(':corpora:anydomain:Brown').tasks.tune_MRG)
        createTasksForCorpus('brown_train', project(':corpora:anydomain:Brown').tasks.train_MRG)
    }
}

project('ensemble_wsj_uni') {
    new EnsembleParser(it).with {
        bllip_parser_dir = ensemble_project.rootProject.file('bllip-parser')
        corpus_name = ':corpora:anydomain:WSJ'
        split_method =  'uni'
        createTasks()
        createTasksForCorpus('wsj_test', project(':corpora:anydomain:WSJ').tasks.test_MRG)
        createTasksForCorpus('wsj_tune', project(':corpora:anydomain:WSJ').tasks.tune_MRG)
        createTasksForCorpus('brown_test', project(':corpora:anydomain:Brown').tasks.test_MRG)
        createTasksForCorpus('brown_tune', project(':corpora:anydomain:Brown').tasks.tune_MRG)
        createTasksForCorpus('brown_train', project(':corpora:anydomain:Brown').tasks.train_MRG)
    }

    task clean_setup << {
        ant.delete {
            set_up.outputs.files.addToAntBuilder(ant, 'resources')
        }
    }

    task list_parsers << {
        childProjects.sort { it.key }.each { println it }
    }
}

project('brown_st_wsj_sepa') {
    // Brown self-training adding SEPA filtered data from WSJ parser to WSJ corpus.
    evaluationDependsOn ':ensemble_wsj_uni'

    project('corpus') {
        def check_output_files = { it.each { mrg_file -> if (!mrg_file.exists()) throw new FileNotFoundException("Missing corpus file: $mrg_file") } }

        task split_MRG(type:DefaultTaskWithEvaluate) {
            ext.train_file = new File(project.projectDir, 'st-train.mrg')
            ext.tune_file = new File(project.projectDir, 'st-tune.mrg')
            ext.weight_multiplier = 1

            outputs.files train_file, tune_file

            doFirst { mkdir(project.projectDir) }

            project.afterEvaluate {
                def input_task = project(':ensemble_wsj_uni').tasks['brown_train-filter']

                inputs.property('weight_multiplier', weight_multiplier)

                evaluateAfterAll([input_task]) {
                    dependsOn input_task
                    def parses_file = input_task.filtered_parses_file
                    inputs.file parses_file
                    doLast {
                        train_file.withPrintWriter { train_writer ->
                        tune_file.withPrintWriter { tune_writer ->
                            def i = 0
                            parses_file.eachLine { line ->
                                if ((++i % 10) == 0) {
                                    weight_multiplier.times { tune_writer.println line }
                                } else {
                                    weight_multiplier.times { train_writer.println line }
                                }
                            }
                        }
                        }
                    }
                    evaluated()
                }
            }
        }

        task train_MRG {
            dependsOn 'split_MRG'
            inputs.files(project(':corpora:anydomain:WSJ').tasks.train_MRG.outputs.files)
            inputs.file split_MRG.train_file
            outputs.files(project(':corpora:anydomain:WSJ').tasks.train_MRG.outputs.files)
            outputs.file split_MRG.train_file
            doFirst { check_output_files(outputs.files) }
        }

        task tune_MRG {
            dependsOn 'split_MRG'
            inputs.files(project(':corpora:anydomain:WSJ').tasks.tune_MRG.outputs.files)
            inputs.file split_MRG.tune_file
            outputs.files(project(':corpora:anydomain:WSJ').tasks.tune_MRG.outputs.files)
            outputs.file split_MRG.tune_file
            doFirst { check_output_files(outputs.files) }
        }

        task list {
            [train_MRG, tune_MRG].each { splitTask ->
                dependsOn splitTask
                doLast { splitTask.outputs.files.each { println it } }
            }
        }
    }

    new CharniakParser(it).with {
        corpus_name = 'corpus'
        base_parser_dir = parser_project.rootProject.file('bllip-parser')
        createTasks()
        createTasksForCorpus('wsj_test', project(':corpora:anydomain:WSJ').tasks.test_MRG)
        createTasksForCorpus('wsj_tune', project(':corpora:anydomain:WSJ').tasks.tune_MRG)
        createTasksForCorpus('brown_test', project(':corpora:anydomain:Brown').tasks.test_MRG)
        createTasksForCorpus('brown_tune', project(':corpora:anydomain:Brown').tasks.tune_MRG)
        createTasksForCorpus('brown_train', project(':corpora:anydomain:Brown').tasks.train_MRG)
    }
}

project('brown_st_wsj') {
    // Brown self-training adding SEPA filtered data from WSJ parser to WSJ corpus.
    evaluationDependsOn ':wsj_only'

    project('corpus') {
        def check_output_files = { it.each { mrg_file -> if (!mrg_file.exists()) throw new FileNotFoundException("Missing corpus file: $mrg_file") } }

        task split_MRG(type:DefaultTaskWithEvaluate) {
            ext.train_file = new File(project.projectDir, 'st-train.mrg')
            ext.tune_file = new File(project.projectDir, 'st-tune.mrg')
            ext.weight_multiplier = 1

            outputs.files train_file, tune_file

            doFirst { mkdir(project.projectDir) }

            project.afterEvaluate {
                def input_task = project(':wsj_only').tasks['brown_train-select']

                inputs.property('weight_multiplier', weight_multiplier)

                evaluateAfterAll([input_task]) {
                    dependsOn input_task
                    def parses_file = input_task.outputs.files.singleFile
                    inputs.file parses_file
                    doLast {
                        train_file.withPrintWriter { train_writer ->
                            tune_file.withPrintWriter { tune_writer ->
                                def i = 0
                                parses_file.eachLine { line ->
                                    if ((++i % 10) == 0) {
                                        weight_multiplier.times { tune_writer.println line }
                                    } else {
                                        weight_multiplier.times { train_writer.println line }
                                    }
                                }
                            }
                        }
                    }
                    evaluated()
                }
            }
        }

        task train_MRG {
            dependsOn 'split_MRG'
            inputs.files(project(':corpora:anydomain:WSJ').tasks.train_MRG.outputs.files)
            inputs.file split_MRG.train_file
            outputs.files(project(':corpora:anydomain:WSJ').tasks.train_MRG.outputs.files)
            outputs.file split_MRG.train_file
            doFirst { check_output_files(outputs.files) }
        }

        task tune_MRG {
            dependsOn 'split_MRG'
            inputs.files(project(':corpora:anydomain:WSJ').tasks.tune_MRG.outputs.files)
            inputs.file split_MRG.tune_file
            outputs.files(project(':corpora:anydomain:WSJ').tasks.tune_MRG.outputs.files)
            outputs.file split_MRG.tune_file
            doFirst { check_output_files(outputs.files) }
        }

        task list {
            [train_MRG, tune_MRG].each { splitTask ->
                dependsOn splitTask
                doLast { splitTask.outputs.files.each { println it } }
            }
        }
    }

    new CharniakParser(it).with {
        corpus_name = 'corpus'
        base_parser_dir = parser_project.rootProject.file('bllip-parser')
        createTasks()
        createTasksForCorpus('wsj_test', project(':corpora:anydomain:WSJ').tasks.test_MRG)
        createTasksForCorpus('wsj_tune', project(':corpora:anydomain:WSJ').tasks.tune_MRG)
        createTasksForCorpus('brown_test', project(':corpora:anydomain:Brown').tasks.test_MRG)
        createTasksForCorpus('brown_tune', project(':corpora:anydomain:Brown').tasks.tune_MRG)
        createTasksForCorpus('brown_train', project(':corpora:anydomain:Brown').tasks.train_MRG)
    }
}

task setup_wsj_only (type:SetUpParser) {
    dependsOn 'corpora:anydomain:WSJ:train_MRG'
    dependsOn 'corpora:anydomain:WSJ:tune_MRG'

    base_parser_dir = file('bllip-parser')
    corpus_name = 'corpora:anydomain:WSJ'
    parser_dir = file('wsj_only')
}

//task train_wsj_only(dependsOn:setup_wsj_only) << {
//    ant.exec(executable:'first-stage/TRAIN/allScript', dir:setup_wsj_only.parser_dir, failonerror:true) {
//        arg(file:setup_wsj_only.model_dir)
//        arg(file:setup_wsj_only.train_all_mrg)
//        arg(file:setup_wsj_only.tune_all_mrg)
//    }
//}

task wrapper(type: Wrapper) {
//  gradleVersion = "1.7-20130626220034+0000"
  gradleVersion = "1.8-20130630220025+0000"
}

allprojects {
//     println project
    task show << { t -> logger.warn "project ${project.absoluteProjectPath(t.name)}" }
}

task list_projects << {
    allprojects.each { println it }
}
